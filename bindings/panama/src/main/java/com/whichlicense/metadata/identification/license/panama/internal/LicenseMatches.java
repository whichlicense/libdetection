// Generated by jextract

package com.whichlicense.metadata.identification.license.panama.internal;

import com.whichlicense.foreign.ForeignRuntimeHelper;

import java.lang.foreign.*;
import java.lang.invoke.VarHandle;

/**
 * {@snippet :
 * struct LicenseMatches {
 *     struct LicenseMatchEntry* matches;
 *     uintptr_t length;
 * };
 *}
 */
public class LicenseMatches {
    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(
            Constants$root.C_POINTER$LAYOUT.withName("matches"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("length")
    ).withName("LicenseMatches");
    static final VarHandle matches$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("matches"));
    static final VarHandle length$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("length"));

    public static MemoryLayout $LAYOUT() {
        return LicenseMatches.$struct$LAYOUT;
    }

    /**
     * Getter for field:
     * {@snippet :
     * struct LicenseMatchEntry* matches;
     *}
     */
    public static MemorySegment matches$get(MemorySegment seg) {
        return (MemorySegment) LicenseMatches.matches$VH.get(seg);
    }

    /**
     * Getter for field:
     * {@snippet :
     * uintptr_t length;
     *}
     */
    public static long length$get(MemorySegment seg) {
        return (long) LicenseMatches.length$VH.get(seg);
    }

    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate($LAYOUT());
    }

    public static MemorySegment ofAddress(MemorySegment addr, SegmentScope scope) {
        return ForeignRuntimeHelper.asArray(addr, $LAYOUT(), 1, scope);
    }

    public static MemorySegment arrayOfAddress(MemorySegment addr, long numElements, SegmentScope scope) {
        return ForeignRuntimeHelper.asArray(addr, $LAYOUT(), numElements, scope);
    }
}

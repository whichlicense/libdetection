// Generated by jextract

package com.whichlicense.metadata.identification.license.panama.internal;

import com.whichlicense.foreign.ForeignRuntimeHelper;
import com.whichlicense.metadata.identification.license.LicenseIdentificationPipelineStepTrace;
import com.whichlicense.metadata.identification.license.LicenseMatch;
import com.whichlicense.metadata.identification.license.LicenseNormalization;

import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.util.*;
import java.util.stream.Collectors;

import static java.lang.foreign.SymbolLookup.loaderLookup;
import static java.util.stream.Collectors.toUnmodifiableList;
import static java.util.stream.Collectors.toUnmodifiableSet;

public final class RuntimeHelper {
    private static final Linker LINKER = Linker.nativeLinker();
    private static final ClassLoader LOADER = RuntimeHelper.class.getClassLoader();
    private static final MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();
    private static final SymbolLookup SYMBOL_LOOKUP;

    static {
        ForeignRuntimeHelper.loadLibrary(LOADER, "identification");
        SYMBOL_LOOKUP = name -> loaderLookup().find(name)
                .or(() -> LINKER.defaultLookup().find(name));
    }

    // Suppresses default constructor, ensuring non-instantiability.
    private RuntimeHelper() {
    }

    static MethodHandle downcallHandle(String name, FunctionDescriptor fdesc) {
        return SYMBOL_LOOKUP.find(name).
                map(addr -> LINKER.downcallHandle(addr, fdesc)).
                orElse(null);
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MH_LOOKUP.findVirtual(fi, name, fdesc.toMethodType());
        } catch (Throwable ex) {
            throw new AssertionError(ex);
        }
    }

    static <Z> MemorySegment upcallStub(MethodHandle fiHandle, Z z, FunctionDescriptor fdesc, SegmentScope scope) {
        try {
            fiHandle = fiHandle.bindTo(z);
            return LINKER.upcallStub(fiHandle, fdesc, scope);
        } catch (Throwable ex) {
            throw new AssertionError(ex);
        }
    }


    public static CNormalizationFn wrapNormalizationFunction(LicenseNormalization normalization, SegmentAllocator allocator) {
        return input -> allocator.allocateUtf8String(normalization.apply(input.getUtf8String(0)));
    }

    public static List<LicenseIdentificationPipelineStepTrace> licenseIdentificationPipelineStepTraceSetOfAddress(MemorySegment addr, String algorithm, SegmentScope scope) {
        record LicenseIdentificationPipelineStepTraceImpl(long step, Set<LicenseMatch> matches,
                                                          boolean terminated) implements LicenseIdentificationPipelineStepTrace {
        }

        var matches = PipelineLicenseMatches.ofAddress(addr, scope);
        var length = PipelineLicenseMatches.length$get(matches);

        return LicenseMatches.arrayOfAddress(PipelineLicenseMatches.step_matches$get(matches), length, scope)
                .elements(LicenseMatches.$LAYOUT())
                .map(element -> new LicenseIdentificationPipelineStepTraceImpl(
                        0, licenseMatchSetOfAddress(element, algorithm, Collections.emptyMap(), scope), false
                ))
                .collect(toUnmodifiableList());
    }

    public static Set<LicenseMatch> licenseMatchSetOfAddress(MemorySegment addr, String algorithm, Map<String, Object> parameters, SegmentScope scope) {
        record LicenseMatchImpl(String license, float confidence, String algorithm,
                                Map<String, Object> parameters) implements LicenseMatch, Comparable<LicenseMatch> {
            @Override
            public int compareTo(LicenseMatch o) {
                return Float.compare(o.confidence(), this.confidence);
            }
        }

        var matches = LicenseMatches.ofAddress(addr, scope);
        var length = LicenseMatches.length$get(matches);

        return LicenseMatchEntry
                .arrayOfAddress(LicenseMatches.matches$get(matches), length, scope)
                .elements(LicenseMatchEntry.$LAYOUT())
                .map(element -> new LicenseMatchImpl(
                        LicenseMatchEntry.name$get(element).getUtf8String(0)
                                .replace(".LICENSE", ""),
                        LicenseMatchEntry.confidence$get(element),
                        algorithm, parameters
                )).collect(Collectors.toCollection(TreeSet::new));
    }
}
